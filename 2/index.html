<!DOCTYPE html>
<html lang='de'>
<head>
<meta charset='utf-8'>
<title>Die Grundlagen von JavaScript: Zweite Ausgabe von Dmitry A. Soshnikov (Deutsche Übersetzung)</title>
<meta name="robots" content="noindex, follow">
<meta name='description' content='Die wichtigsten Konzepte und Interna von JavaScript / ECMAScript 8 (2017)'>
<meta name='viewport' content='width=device-width'>
<style>
*, *::before, *::after {
  box-sizing: inherit;
}

html {
  margin: 0;
  padding: 2rem;
}

body {
  margin: 0 auto;
  max-width: 43rem;
  color: #202020;
  background-color: white;
  font-family: 'Fontin Sans', '-apple-system', system-ui, BlinkMacSystemFont, 'Helvetica Neue', Helvetica, Arial, sans-serif;
  line-height: 1.78;
}

header {
  margin: 3rem 0;
  text-align: center;
}

h1 {
  border-style: solid none solid;
  border-width: 2px;
  border-color: navy;
  margin: 0;
  padding: 2rem 0;
  font-size: 2.5rem;
  font-weight: normal;
  line-height: 1.4;
}

.subtitle {
  margin: 1rem 0;
  font-size: 1.2rem;
}

nav {
  margin: 2rem 0;
}

h2 {
  margin: 2rem 0 1.5rem;
  border-bottom: 2px solid navy;
  padding-left: 2px;
  font-size: 1.7rem;
  font-weight: normal;
}

p, pre {
  margin-top: 1.5rem;
  margin-bottom: 1.5rem;
}

.definition {
  margin-left: 3px;
  border-left: 3px solid navy;
  padding-left: 1rem;
  color: black;
}

.note {
  padding-left: 2rem;
  font-size: 0.95rem;
}

figure {
  margin: 2rem 0;
}

figcaption {
  margin-top: 1rem;
  text-align: center;
  color: #666;
  font-style: italic;
}

figcaption table {
  margin: auto;
  border-collapse: collapse;
  font-size: 0.9rem;
  font-style: normal;
  color: #202020;
}

figcaption caption {
  margin-bottom: 0.5rem;
  font-size: 1.1rem;
}

figcaption th,
figcaption td {
  text-align: left;
  border-bottom: 1px solid #ddd;
  padding: 0.25rem 0.5rem;
}

img {
  display: block;
  margin: auto;
  max-width: 100%;
}

pre, code {
  color: #02a;
  font-family: 'Monaco', 'Consolas', 'Droid Sans Mono', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', 'Liberation Mono', 'Courier New', monospace;
}

pre {
  border: 1px solid #e0e0e0;
  padding: 1rem 1.5rem;
  background-color: #fbfbfb;
  font-size: 0.9rem;
  line-height: 1.5;
  white-space: pre-wrap;
}

pre strong {
  color: green;
  font-weight: normal;
}

code {
  padding: 2px;
}

a:link {
  color: #00b;
}

em[lang='en'] {
  color: #705050;
}

.bct {
  margin: 0;
  font-size: 80%;
}

hr {
  border-style: none none solid;
  border-width: 1px;
  border-color: #ccc;
  height: 0;
}

.translation-note {
  color: #505050;
  font-size: 0.9rem;
  text-align: left;
  font-style: normal;
}
</style>
</head>
<body>

<p class='bct'>
  <a href='https://molily.de/' title='Startseite'>molily.de</a>
</p>

<header>
  <h1>
    Die Grundlagen von JavaScript:<br>Zweite Ausgabe
  </h1>
  <p class='subtitle'>Deutsche Übersetzung des Artikels
    <a href='http://dmitrysoshnikov.com/ecmascript/javascript-the-core-2nd-edition/'>JavaScript. The Core: 2nd Edition</a><br>
    von <a href='http://dmitrysoshnikov.com/'>Dmitry A. Soshnikov</a>
  </p>
</header>

<p>Dies ist die <strong>zweite Ausgabe</strong> des Übersichtsartikels <a href='http://dmitrysoshnikov.com/ecmascript/javascript-the-core/' lang='de'>JavaScript. The Core</a>, der sich der Programmiersprache ECMAScript und den Kernkomponenten ihrer Laufzeitumgebung widmet.</p>

<p>Die <strong>Zielgruppe</strong> dieses Artikels sind erfahrene ProgrammiererInnen und ExpertInnen.</p>

<nav>
  <ol>
    <li><a href='#object'>Objekt</a></li>
    <li><a href='#prototype'>Prototyp</a></li>
    <li><a href='#class'>Klasse</a></li>
    <li><a href='#execution-context'>Ausführungskontext</a></li>
    <li><a href='#environment'>Umgebung</a>
    </li>
    <li><a href='#closure'>Closure</a></li>
    <li><a href='#this'>This</a></li>
    <li><a href='#realm'>Gebiet</a></li>
    <li><a href='#job'>Auftrag</a></li>
    <li><a href='#agent'>Agent</a></li>
  </ol>
</nav>

<p>Die <a href='http://dmitrysoshnikov.com/ecmascript/javascript-the-core/' lang='en'>erste Ausgabe dieses Artikels</a> (<a href='../'>deutsche Übersetzung</a>) behandelt die allgemeinen Aspekte der Sprache JavaScript unter Bezugnahme auf Konzepte der veralteten ECMAScript-3-Spezifikation mit ein paar Verweisen auf Änderungen in ECMAScript 5 und 6 (auch ES2015 genannt).</p>
<p>Mit ES2015 änderten sich die Beschreibungen und Strukturen mancher Kernkomponenten. Neue Modelle wurden eingeführt. In dieser Ausgabe richten wir unser Augenmerk auf die neueren Konzepte und die aktualisierte Terminologie. Dabei behalten wir die fundamentalen JavaScript-Strukturen bei, die durch die Versionen gleich geblieben sind. </p>
<p>Dieser Artikel deckt die Laufzeitumgebung von ECMAScript 2017 und neuer ab.</p>
<p class='note'><strong>Hinweis:</strong> Die neueste Version der <a href='https://tc39.github.io/ecma262/'>ECMAScript-Spezifikation</a> finden Sie auf der Website der <abbr title='Technical Committee' lang='en'>TC</abbr>-39-Arbeitsgruppe.</p>
<p>Wir beginnen die Abhandlung mit dem Konzept des <em>Objekts</em>, denn es ist fundamental für ECMAScript.</p>

<h2 id='object'>Objekt</h2>
<p>ECMAScript ist eine <em>objektorientierte</em> Programmiersprache mit einem <em>prototyp-basierten</em> Aufbau. Dabei ist das Konzept des <em>Objekts</em> die grundlegende Abstraktion.</p>
<p class='definition'>
  <strong>Definition 1: Objekt:</strong> Ein <em>Objekt</em> ist eine <em>Sammlung von Eigenschaften</em>. Es besitzt ein <em>einziges Prototyp-Objekt</em>. Der Prototyp ist entweder ein Objekt oder der Wert <code>null</code>.
</p>
<p>Schauen wir uns ein einfaches Beispielobjekt an. Der Prototyp eines Objekts ist in der internen Eigenschaft <code>[[Prototype]]</code> gespeichert. Beim Programmieren ist dieser Verweis über die Eigenschaft <code>__proto__</code> zugänglich.</p>
<p>Der Beispielcode:</p>
<pre>
let point = {
  x: 10,
  y: 20,
};
</pre>
<p>Dieses Objekt ist so aufgebaut, dass es zwei <em>ausdrückliche, eigene Eigenschaften</em> und eine <em>implizite</em> Eigenschaft besitzt. Letztere ist der Verweis auf den Prototyp von <code>point</code>:</p>
<figure>
  <img src='js-object.png' width='500' alt='Abbildung 1. Ein einfaches Objekt mit einem Prototyp.' />
  <figcaption>
    <p>Abbildung 1. Ein einfaches Objekt mit einem Prototyp.</p>
    <table>
      <caption>Legende</caption>
      <tr><th lang='en'>some properties</th><td>einige Eigenschaften</td></tr>
    </table>
  </figcaption>
</figure>
<p class='note'><strong>Hinweis:</strong> Objekte können auch <em>Symbole</em> speichern. Sie finden mehr <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol'>Informationen zu Symbolen in dieser Dokumentation</a>.
</p>
<p>Prototypen-Objekte dienen dazu, um <em>Vererbung</em> mithilfe der <em>dynamischen Bindung</em> (<em lang='en'>dynamic dispatch</em>) umzusetzen. Schauen wir uns das Konzept der Prototypen-Kette an, um diesen Mechanismus zu verstehen.</p>

<h2 id='prototype'>Prototyp</h2>
<p>Jedes Objekt bekommt in dem Moment, in dem erzeugt wird, einen <em>Prototypen</em> zugewiesen. Falls der Prototyp nicht <em>ausdrücklich</em> gesetzt wird, so erbt das Objekt vom <em>Standard-Prototypen</em>.</p>
<p class='definition'><strong>Definition 2: Prototyp:</strong> Ein <em>Prototyp</em> ist ein Stellvertreter-Objekt, an das delegiert wird. Mithilfe dieser Delegation wird eine <em>Prototypen-basierte Vererbung</em> umgesetzt.</p>
<p>Der Prototyp kann entweder <em>ausdrücklich</em> über die Eigenschaft <code>__proto__</code> gesetzt werden oder über die Methode <code>Object.create</code>:</p>
<pre>
// Basis-Objekt.
let point = {
  x: 10,
  y: 20,
};

// Erbe vom Objekt `point`.
let point3D = {
  z: 30,
  __proto__: point,
};

console.log(
  point3D.x, // 10, vererbte Eigenschaft
  point3D.y, // 20, vererbte Eigenschaft
  point3D.z  // 30, eigene Eigenschaft
);
</pre>
<p class='note'><strong>Hinweis:</strong> Standardmäßig erben Objekte von <code>Objekt.prototype</code>.</p>
<p>Jedes Objekt kann als Prototyp eines anderen Objekts dienen. Der Prototyp wiederum kann einen eigenen Prototyp haben. Wenn ein Prototyp ein Verweis auf einen weiteren Prototyp hat und dieser nicht <code>null</code> ist, so spricht man von einer <em>Prototypen-Kette</em>.</p>
<p class='definition'><strong>Definition 3: Prototypen-Kette</strong>: Eine <em>Prototypen-Kette</em> ist eine <em>endliche</em> Kette von Objekten. Sie dient dazu, <em>Vererbung</em> und <em>gemeinsame Eigenschaften</em> umzusetzen.</p>
<figure>
  <img src='prototype-chain.png' width='600' alt='Figure 2. Eine Prototypen-Kette.'>
  <figcaption>
    <p>Abbildung 2. Eine Prototypen-Kette.</p>
    <p class='translation-note'>Anmerkung der Übersetzung: Die Illustration zeigt die Prototypen-Kette für den obigen Beispielcode. Die Kette beginnt mit dem Objekt <code>point3D</code> auf der linken Seite. Es hat das Objekt <code>point</code> als Prototypen, daher zeigt ein Verweis-Pfeil darauf. <code>point</code> wiederum besitzt den Standard-Prototypen <code>Object.prototype</code>, daher ein weiterer Verweis-Pfeil. <code>Object.prototype</code> hat schließlich keinen Prototypen mehr (<code>null</code>).</p>
  </figcaption>
</figure>
<p>Die Funktionsweise ist sehr einfach: Wenn eine Eigenschaft am Objekt selbst nicht gefunden wird, so wird versucht, sie am Prototyp <em>aufzulösen</em>, dann an dessen Prototyp und so weiter – bis die gesamte Prototypen-Kette abgesucht wurde.</p>
<p>Der Fachbegriff für diesen Mechanismus lautet <em>dynamische Bindung</em> oder auch <em>Delegation</em>.</p>
<p class='definition'><strong>Definition 4: Delegation:</strong> Ein Mechanismus zur Auflösung einer Eigenschaft entlang der Vererbungskette. Dieser Prozess findet zur Laufzeit statt, daher wird er auch <strong><em>dynamische Bindung</em></strong> (<em lang='en'>dynamic dispatch</em>) genannt.</p>
<p class='note'><strong>Hinweis:</strong> Bei der <em>statischen Bindung</em> werden Verweise schon zur Übersetzungszeit (zum Zeitpunkt des Kompilierens) aufgelöst. Bei der <em>dynamischen Bindung</em> hingegen werden Verweise erst zur Laufzeit aufgelöst.</p>
<p>Wenn eine Eigenschaft in der Prototypen-Kette nicht gefunden wurde, wird der Wert <code>undefined</code> zurückgegeben:</p>
<pre>
// Ein »leeres« Objekt.
let empty = {};

console.log(

  // Eine Funktion vom Standard-Prototypen
  empty.toString,

  // undefined
  empty.x,

);
</pre>
<p>Wie wir sehen, ist ein einfaches Objekt tatsächlich <em>niemals leer</em> – es erbt immer <em>etwas</em> von <code>Object.prototype</code>. Wenn wir ein <a href='https://de.wikipedia.org/wiki/Assoziatives_Datenfeld'>Assoziatives Datenfeld</a> (auch Map oder Dictionary genannt) benötigen, so müssen wir ein Objekt ohne Prototyp erzeugen. Dazu müssen wir ausdrücklich den Prototyp auf <code>null</code> setzen:</p>
<pre>
// Dieses Objekt erbt keine Eigenschaften.
let dict = Object.create(null);

console.log(dict.toString); // undefined
</pre>
<p>Die <em>dynamische Bindung</em> ermöglicht das <em>uneingeschränkte Ändern</em> der Vererbungskette. Sie erlaubt es, das Objekt zu ändern, an das delegiert wird:</p>
<pre>
let protoA = {x: 10};
let protoB = {x: 20};

// Dies ist gleichwertig mit `let objectC = {__proto__: protoA};`:
let objectC = Object.create(protoA);
console.log(objectC.x); // 10

// Ändern des Prototyps (das Objekt, an das delegiert wird):
Object.setPrototypeOf(objectC, protoB);
console.log(objectC.x); // 20
</pre>
<p class='note'><strong>Hinweis:</strong> Die Eigenschaft <code>__proto__</code> ist zwar mittlerweile standardisiert und eignet sich besser für Erklärungen wie die obige. In der Praxis sollten Sie jedoch die API-Methoden verwenden, die für die Änderung des Prototyps konzipiert wurden. Das sind <code>Object.create</code>, <code>Object.getPrototypeOf</code>, <code>Object.setPrototypeOf</code> und ähnliche am <code>Reflect</code>-Modul.</p>
<p>Am Beispiel von <code>Object.prototype</code> zeigt sich, dass sich <em>viele Objekte</em> <em>denselben Prototyp</em> teilen können. Auf diesem Prinzip basiert die <em>klassen-basierte Vererbung</em> in ECMAScript. Schauen wir uns anhand eines Beispiels unter die Haube der Abstraktion der »Klasse«.</p>

<h2 id='class'>Klasse</h2>
<p>Wenn mehrere Objekte denselben Zustand und dasselbe Verhalten haben, so bilden sie eine <em>Klassifikation</em>.</p>
<p class='definition'><strong>Definition 5: Klasse:</strong> Eine <em>Klasse</em> ist eine formale und abstrakte Menge, die den anfänglichen Zustand sowie das Verhalten ihrer Objekte definiert.</p>
<p>Wenn wir möchten, dass <em>mehrere Objekte</em> vom selben Prototyp erben, so könnten wir natürlich diesen Prototyp erzeugen und dann neue Objekte ausdrücklich von ihm erben lassen:</p>
<pre>
// Allgemeiner Prototyp für alle Buchstaben.
let letter = {
  getNumber() {
    return this.number;
  }
};

let a = {number: 1, __proto__: letter};
let b = {number: 2, __proto__: letter};
// ...
let z = {number: 26, __proto__: letter};

console.log(
  a.getNumber(), // 1
  b.getNumber(), // 2
  z.getNumber(), // 26
);
</pre>
<p>Wir können die Beziehungen zwischen den Objekten folgendermaßen veranschaulichen:</p>
<figure>
  <img src='shared-prototype.png' width='500' alt='Abbildung 3. Ein geteilter Prototyp.'>
  <figcaption>
    <p>Abbildung 3. Ein geteilter Prototyp.</p>
    <table>
      <caption>Legende</caption>
      <tr><th lang='en'>built-ins</th><td>Eingebaute Eigenschaften der ECMAScript-Kernobjekte</td></tr>
    </table>
  </figcaption>
</figure>
<p>Allerdings ist das offensichtlich <em>mühsam</em>. Die Abstraktion der Klasse hilft uns hier weiter, denn sie dient genau einem Zweck: Sie ist »Syntaxzucker« für das komfortable Erzeugen mehrerer solcher Objekte. (»Syntaxzucker« ist ein Sprachkonstrukt, das <em>semantisch</em> dasselbe tut, allerdings in einer <em>schöneren syntaktischen Form</em>.)</p>
<pre>
class Letter {
  constructor(number) {
    this.number = number;
  }

  getNumber() {
    return this.number;
  }
}

let a = new Letter(1);
let b = new Letter(2);
// ...
let z = new Letter(26);

console.log(
  a.getNumber(), // 1
  b.getNumber(), // 2
  z.getNumber(), // 26
);
</pre>
<p class='note'><strong>Hinweis:</strong> <em>Klassen-basierte Vererbung</em> in ECMAScript ist auf Basis der <em>Prototyp-basierten Delegation</em> umgesetzt.</p>
<p class='note'><strong>Hinweis:</strong> Eine <em>»Klasse«</em> ist lediglich eine <em>theoretische Abstraktion</em>. Technisch gesehen kann sie mittels <em>statischer Bindung</em> umgesetzt werden, wie in Java oder C++, oder mittels <em>dynamischer Bindung (Delegation)</em>, wie in JavaScript, Python, Ruby usw.</p>
<p>Intern wird eine »Klasse« durch zwei Bestandteile abgebildet: eine Konstruktorfunktion und ein Prototyp. Die Konstruktorfunktion <em>erzeugt Objekte</em>. Außerdem setzt sie <em>automatisch</em> den <em>Prototyp</em> der von ihr erzeugten Instanzen. Dieser Prototyp ist in der Eigenschaft <code>&lt;Konstruktorfunktion&gt;.prototype</code> gespeichert.</p>
<p class='definition'><strong>Definition 6: Konstruktor:</strong> Ein <em>Konstruktor</em> ist eine Funktion zum Erzeugen von Instanzen. Sie setzt automatisch deren Prototyp.</p>
<p>Es ist durchaus möglich, eine Konstruktorfunktion direkt zu definieren. Bevor die Klassen-Abstraktion eingeführt wurde, haben JavaScript-EntwicklerInnen dies in Ermangelung einer besseren Alternative lange getan. Wir finden immer noch eine Menge dieser Hinterlassenschaften im Internet verstreut:</p>
<pre>
function Letter(number) {
  this.number = number;
}

Letter.prototype.getNumber = function() {
  return this.number;
};

let a = new Letter(1);
let b = new Letter(2);
// ...
let z = new Letter(26);

console.log(
  a.getNumber(), // 1
  b.getNumber(), // 2
  z.getNumber(), // 26
);
</pre>
<p>Einen losgelösten Konstruktor so zu notieren war noch recht einfach. Eine Vererbungsstruktur hingegen benötigte einen langen Codebaustein. Heute ist dieser Code versteckt und nur noch ein <em>Implementierungsdetail</em>. Doch unter der Haube passiert nach wie vor dasselbe, wenn wir in JavaScript eine Klasse erzeugen.</p>
<p class='note'><strong>Hinweis:</strong> <em>Konstruktorfunktionen</em> sind ein <em>Implementierungsdetail</em> der Klassen-basierten Vererbung.</p>
<p>Schauen wir uns die Beziehungen zwischen den Objekten und ihrer Klasse an:</p>
<figure>
  <img src='js-constructor.png' alt='Abbildung 4. Die Beziehungen zwischen Objekten und dem Konstruktor.'>
  <figcaption>
    <p>Abbildung 4. Die Beziehungen zwischen Objekten und dem Konstruktor.</p>
    <table>
      <caption>Legende</caption>
      <tr><th lang='en'>built-ins</th><td>Eingebaute Eigenschaften der ECMAScript-Kernobjekte</td></tr>
    </table>
  </figcaption>
</figure>
<p>Die Abbildung zeigt, dass <em>jedes Objekt</em> mit einem Prototypen verbunden ist. Sogar die Konstruktorfunktion (die Klasse) <code>Letter</code> hat ihren eigenen Prototyp, nämlich <code>Function.prototype</code>. Beachten Sie, dass <code>Letter.prototype</code> der Prototyp aller <code>Letter</code>-<em>Instanzen</em> ist. Das sind <code>a</code>, <code>b</code> und <code>z</code>.</p>
<p class='note'><strong>Hinweis:</strong> Der <em>tatsächliche</em> Prototyp eines <em>jeden</em> Objekts steckt immer in der Eigenschaft <code>__proto__</code>. Die ausdrückliche Eigenschaft <code>prototype</code> der Konstruktorfunktion verweist auf den Prototyp <em>all ihrer Instanzen</em>. Die Instanzen verweisen auf den Prototyp nach wie vor mit der Eigenschaft <code>__proto__</code>. Genaues finden Sie <a href='http://dmitrysoshnikov.com/ecmascript/chapter-7-2-oop-ecmascript-implementation/#explicit-codeprototypecode-and-implicit-codeprototypecode-properties'>in diesem Artikel</a>.</p>
<p>Sie finden eine detaillierte Erörterung der allgemeinen <abbr title='objekt-orientierte Programmierung'>OOP</abbr>-Konzepte einschließlich einer Beschreibung von Klassen-Basierung, Prototypen-Basierung usw. im Artikel <a href='http://dmitrysoshnikov.com/ecmascript/chapter-7-1-oop-general-theory/'>ES3. 7.1 OOP: The general theory</a>.</p>
<p>Nachdem wir uns die grundlegenden Verbindungen zwischen ECMAScript-Objekten angesehen haben, werfen wir einen genaueren Blick auf die JavaScript-<em>Laufzeitumgebung</em>. Wie wir später sehen werden, kann fast alles darin ebenfalls als Objekt beschrieben werden.</p>

<h2 id='execution-context'>Ausführungskontext</h2>
<p>Um JavaScript-Code auszuführen und den Überblick über die Auswertung zur Laufzeit zu behalten, definiert die ECMAScript-Spezifikation das Konzept des <em>Ausführungskontexts</em>. Diese Ausführungskontexte werden in einem <em><a href='https://de.wikipedia.org/wiki/Stapelspeicher'>Stapelspeicher (Stack)</a></em> vorgehalten. Wir kommen bald auf diesen <em>Stapel von Ausführungskontexten</em> zu sprechen. Er entspricht dem allgemeinen Konzept des <em><a href='https://de.wikipedia.org/wiki/Aufrufstapel'>Aufrufstapels</a></em>.</p>
<p class='definition'><strong>Definition 7: Ausführungskontext:</strong> Ein <em>Ausführungskontext</em> (<em lang='en'>execution context</em>) ist das Mittel der ECMAScript-Spezifikation, um die Auswertung des Codes zur Laufzeit zu protokollieren.</p>
<p>Es gibt verschiedene Arten von ECMAScript-Code: <em>globalen Code</em>, <em>Funktionscode</em>, <code>eval</code>-Code und <em>Modul-Code</em>. Jede dieser Codearten wird in einem eigenen Kontext ausgewertet. Verschiedene Arten von Code und ihre jeweiligen Objekte beeinflussen die Struktur des Ausführungskontexts. Zum Beispiel speichern <em>Generator-Funktionen</em> ihr <em>Generator-Objekt</em> im Ausführungskontext.</p>
<p>Schauen wir uns einen rekursiven Funktionsaufruf an:</p>
<pre>
function recursive(flag) {

  // Abbruchbedingung
  if (flag === 2) {
    return;
  }

  // Rekursiver Aufruf.
  recursive(++flag);
}

// Los!
recursive(0);
</pre>
<p>Wenn eine Funktion aufgerufen wird, so wird ein <em>neuer Ausführungskontext</em> erzeugt und <em>auf den Stapel gelegt</em> (<em lang='en'>Push</em>). Damit wird er zum <em>aktiven Ausführungskontext</em>. Nachdem sich eine Funktion beendet, wird der Kontext wieder vom Stapel genommen (<em lang='en'>Pop</em>).</p>
<p>Der Kontext, der einen anderen Kontext aufruft, wird <em>Aufrufer</em> (<em lang='en'>caller</em>) genannt. Der aufgerufene Kontext wird dementsprechend <em>Aufgerufener</em> (<em lang='en'>callee</em>) genannt. Im obigen Beispiel spielt die <em>rekursive</em> Funktion beide Rollen: Die des Aufgerufenen und die des Aufrufers, wenn sie sich selbst rekursiv aufruft.</p>
<p class='definition'><strong>Definition 8: Stapel von Ausführungskontexten:</strong> Der Stapel von Ausführungskontexten (<em lang='en'>execution context stack</em>) ist eine Datenstruktur der Sorte <em lang='em'>Last In First out (LIFO)</em>, mit der der Kontrollfluss und die Ausführungsreihenfolge gesteuert wird.</p>
<p>In unserem Beispiel finden folgende <em>Push- und Pop-Änderungen</em> am Stack statt:</p>
<figure>
  <img src='execution-stack.png' alt='Abbildung 5. Ein Stapel von Ausführungskontexten.'>
  <figcaption>
    <p>Abbildung 5. Ein Stapel von Ausführungskontexten.</p>
    <table>
      <caption>Legende</caption>
      <tr><th lang='en'>EC stack</th><td>Stapel von Ausführungskontexten</td></tr>
      <tr><th lang='en'>Global context</th><td>Globaler Kontext</td></tr>
    </table>
    <p class='translation-note'>Anmerkung der Übersetzung: Die Pfeile zeigen die Reihenfolge der Änderungen am Stapel an. Zunächst liegt nur der globale Kontext auf dem Stapel, dann werden nach und nach Kontexte auf den Stapel gelegt (entlang der Pfeile nach rechts). Schließlich werden nach und nach Kontexte wieder vom Stapel genommen (entlang der Pfeile nach links). Der Stapel wird wieder abgebaut.</p>
  </figcaption>
</figure>
<p>Wir können in der Illustration sehen, dass der <em>globale Kontext</em> immer zuunterst im Stapel liegt. Er wird erzeugt, bevor alle anderen Kontexte ausgeführt werden.</p>
<p>Mehr Informationen zu Ausführungskontexten in ECMAScript finden Sie <a href='http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/'>im entsprechenden Kapitel</a>.</p>
<p>Normalerweise läuft der Code in einem Kontext <em>bis zu seinem Ende</em>. Wie wir bereits angemerkt haben, verstoßen manche Objekte gegen die <abbr title='Last In First Out'>LIFO</abbr>-Regel des Stapelspeichers – zum Beispiel <em>Generatoren</em>. Eine Generator-Funktion kann ihren aktiven Kontext vorübergehend schlafen legen und ihn vorzeitig <em>vom Stapel nehmen</em>, noch bevor der Code darin vollständig ausgeführt wurde. Sobald der Generator wieder aktiviert wird, wird der Kontext wieder <em>aufgeweckt</em> und <em>auf den Stapel gelegt</em>:</p>
<pre>
function *gen() {
  yield 1;
  return 2;
}

let g = gen();

console.log(
  g.next().value, // 1
  g.next().value, // 2
);
</pre>
<p>Das <code>yield</code>-Statement gibt einen Wert an den Aufrufer zurück und nimmt den Kontext vom Stapel. Beim zweiten Aufruf der <code>next</code>-Methode wird <em>eben dieser Kontext</em> wieder auf den Stapel gelegt und die Ausführung wird wiederaufgenommen. Ein solcher Kontext kann <em>länger leben</em> als der Aufrufer, der ihn erzeugt hat. Dies ist der besagte Verstoß gegen die <abbr title='Last In First Out'>LIFO</abbr>-Datenstruktur.</p>
<p class='note'><strong>Hinweis:</strong> Mehr über Generatoren und Iteratoren finden Sie <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators'>in dieser Dokumentation</a>.</p>
<p>Wir schauen uns nun die wichtigen Teile eines Ausführungskontexts an. Insbesondere werden wir erfahren, wie die ECMAScript-Laufzeitumgebung die <em>Speicherung von Variablen</em> bewerkstellt und wie verschachtelte Code-Blöcke <em>Geltungsbereiche</em> erzeugen. Das dahinterstehende Konzept heißt <em>lexikalische Umgebung</em>. Es wird in JavaScript genutzt, um Daten zu speichern und das »Funarg-Problem« mithilfe von <em>Closures</em> zu lösen.</p>

<h2 id='environment'>Umgebung</h2>
<p>Jeder Ausführungskontext hat eine zugehörige <em>lexikalische Umgebung</em>.</p>
<p class='definition'><strong>Definition 9: Lexikalische Umgebung:</strong> Die <em>lexikalische Umgebung</em> (<em lang='en'>lexical environment</em>) ist eine Datenstruktur, in der Verbindungen zwischen den <em>Bezeichnern</em> (<em lang='en'>identifiers</em>) eines Kontexts und ihren Werten gespeichert werden. Jede Umgebung kann einen Verweis auf eine <em>Eltern-Umgebung</em> besitzen.</p>
<p>Eine Umgebung ist also ein <em>Speicher</em> mit allen Variablen, Funktionen und Klassen, die in einem Geltungsbereich definiert sind.</p>
<p>Technisch gesehen besteht eine Umgebung aus zwei Teilen: Zum einen das <em>Umgebungsregister</em> (<em lang='en'>environment record</em>). Dies ist die tatsächliche Speichertabelle, die Bezeichner auf ihre Werte abbildet. Zum anderen der Verweis auf die Elternumgebung, der <code>null</code> sein kann.</p>
<p>Untersuchen wir folgenden Code:</p>
<pre>
let x = 10;
let y = 20;

function foo(z) {
  let x = 100;
  return x + y + z;
}

foo(30); // 150
</pre>
<p>Die Umgebungen des <em>globalen Kontexts</em> und des Kontexts der Funktion <code>foo</code> sehen wie folgt aus:</p>
<figure>
  <img src='environment-chain.png' width='400' alt='Abbildung 6. Eine Kette von Umgebungen'>
  <figcaption>
    <p>Abbildung 6. Eine Kette von Umgebungen</p>
    <table>
      <caption>Legende</caption>
      <tr><th lang='en'>foo env</th><td>Umgebung der Funktion <code>foo</code></td></tr>
      <tr><th lang='en'>Foo EnvRec</th><td>Umgebungsregister der Funktion <code>foo</code></td></tr>
      <tr><th lang='en'>Global env</th><td>Globale Umgebung</td></tr>
      <tr><th lang='en'>Global EnvRec</th><td>Globales Umgebungsregister</td></tr>
    </table>
  </figcaption>
</figure>
<p>Dieser Aufbau erinnert uns stark an die <em>Prototypen-Kette</em>, die wir oben kennengelernt haben. Und tatsächlich funktioniert die <em>Auflösung von Bezeichnern</em> (<em lang='en'>identifier resolution</em>) sehr ähnlich: Wenn eine Variable in der <em>eigenen</em> Umgebung nicht gefunden wird, so wird versucht, sie in der <em>Elternumgebung</em> nachzuschlagen, dann in deren Elternumgebung und so weiter – bis die gesamte <em>Kette von Umgebungen</em> abgesucht wurde.</p>
<p class='definition'><strong>Definition 10: Auflösung von Bezeichnern:</strong> Der Vorgang des Auflösens einer Variable (einer <em>Verbindung</em> zwischen Name und Wert, Englisch <em lang='en'>binding</em>) entlang der Kette von Umgebungen. Wenn ein Verbindung nicht aufgelöst werden kann, so tritt ein <code>ReferenceError</code> auf.</p>
<p>Dies erklärt, warum im Beispiel die Variable <code>x</code> zum Wert <code>100</code> aufgelöst wird und nicht etwa zum Wert <code>10</code> – die Variable wird direkt in der <em>eigenen</em> Umgebung der Funktion <code>foo</code> gefunden. Dies erklärt auch, warum wir auf den Funktionsparameter <code>z</code> zugreifen können – der Parameter wird ebenfalls in der <em>Aktivierungsumgebung</em> gespeichert. Schließlich verstehen wir nun, warum wir auf die Variable <code>y</code> zugreifen können – sie wird in der Elternumgebung gefunden.</p>
<p>Ähnlich wie bei Prototypen können sich verschiedene Kindumgebung ein und dieselbe Elternumgebung teilen: Beispielsweise teilen sich zwei globale Funktionen dieselbe globale Umgebung.</p>
<p class='note'><strong>Hinweis:</strong> Mehr Informationen über lexikalische Umgebungen finden Sie <a href='http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/'>in diesem Artikel</a>.</p>
<p>Der Aufbau eines Umgebungsregisters hängt vom <em>Typ</em> der Umgebung ab. Es gibt <strong><em>Objekt</em></strong>-Umgebungsregister und <strong><em>deklarative</em></strong> Umgebungsregister. Zwei Untertypen des deklarativen Registers sind <strong><em>Funktions</em></strong>- und <strong><em>Modul</em></strong>-Umgebungsregister. Jeder Registertyp bringt eigentümliche Eigenschaften mit sich. Der generelle Mechanismus der Auflösung von Bezeichnern hingegen ist bei allen Umgebungen gleich, er hängt nicht vom Registertyp ab.</p>
<p>Ein Beispiel für ein <em>Objekt-Umgebungsregister</em> ist das Register der <em>globalen Umgebung</em>. Dieses Register besitzt ein zugehöriges <em>Verbindungsobjekt</em> (<em lang='en'>binding object</em>). Das Verbindungsobjekt kann einige Eigenschaften des Registers speichern, aber nicht alle. Dasselbe gilt umgekehrt. Das Verbindungsobjekt kann außerdem als <code>this</code>-Wert dienen.</p>
<pre>
// Herkömmliche Variablen mit `var`.
var x = 10;

// Moderne Variablen mit `let`.
let y = 20;

// Beide werden dem Umgebungsregister hinzugefügt:
console.log(
  x, // 10
  y, // 20
);

// Lediglich `x` wird zum »Verbindungsobjekt« hinzugefügt.
// Das Verbindungsobjekt der globalen Umgebung ist
// das globale Objekt, das auch über `this` verfügbar ist:

console.log(
  this.x, // 10
  this.y, // undefined!
);

// Das Verbindungsobjekt kann einen Namen speichern,
// der nicht im Umgebungsregister steht,
// weil er kein gültiger Bezeichner ist:

this['not valid ID'] = 30;

console.log(
  this['not valid ID'], // 30
);
</pre>
<p>Dies wird veranschaulicht in der folgenden Abbildung:</p>
<figure>
  <img src='env-binding-object.png' width='500' alt='Abbildung 7. Ein Verbindungsobjekt.'>
  <figcaption>
    <p>Abbildung 7. Ein Verbindungsobjekt.</p>
    <table>
      <caption>Legende</caption>
      <tr><th lang='en'>Global env</th><td>Globale Umgebung</td></tr>
      <tr><th lang='en'>Global EnvRec</th><td>Globales Umgebungsregister</td></tr>
      <tr><th lang='en'>Global EnvRec BindingObject</th><td>Verbindungsobjekt des globalen Umgebungsregisters</td></tr>
    </table>
  </figcaption>
</figure>
<p>Beachten Sie, dass das Verbindungsobjekt bloß existiert, um <em>veraltete Sprachkonstrukte</em> abzudecken. Das sind beispielsweise die <code>var</code>-Deklaration und das <code>with</code>-Statement, das ein Objekt als Verbindungsobjekt zur Verfügung stellt. Aus historischen Gründen wurde eine Umgebung als einfaches Objekt modelliert. Heute hingegen ist das Modell der Umgebungen weit ausgereifter. Dies hat jedoch dazu geführt, dass wir auf Verbindungen nicht mehr als Eigenschaften zugreifen können.</p>
<p>Wir haben gelernt, dass Umgebungen miteinander über den Eltern-Verweis verknüpft sind. Nun werden wir sehen, wie eine Umgebung <em>länger leben</em> kann als der Kontext, der sie erzeugt hat. Dies ist nämlich die Voraussetzung für den Mechanismus der <em>Closure</em>, den wir nun erörtern werden.</p>

<h2 id='closure'>Closure</h2>
<p>Funktionen in JavaScript sind Objekte <em>erster Klasse</em>. Dieses Konzept liegt der <em>funktionalen Programmierung</em> zugrunde. JavaScript unterstützt einige Aspekte der funktionalen Programmierung.</p>
<p class='definition'><strong>Definition 11: Funktion erster Klasse (<em lang='en'>first-class function</em>)</strong>: Eine Funktion, die sich wie normale Daten verhält: Sie kann in einer Variable gespeichert werden, als Parameter übergeben werden oder als Wert von einer anderen Funktion zurückgegeben werden.</p>
<p>Eng verknüpft mit dem Konzept der Funktionen erster Klasse ist das sogenannte <a href='https://en.wikipedia.org/wiki/Funarg_problem'>»Funarg problem«</a> (das <em>Problem des funktionalen Parameters</em>). Dieses Problem tritt auf, wenn eine Funktion auf <em>freie Variablen</em> zugreifen muss.</p>
<p class='definition'><strong>Definition 12: Freie Variable:</strong> eine Variable, die <em>weder ein Parameter</em> noch eine <em>lokale Variable</em> der jeweiligen Funktion ist.</p>
<p>Schauen wir uns das Funarg-Problem und seine Lösung in ECMAScript an.</p>
<p>Untersuchen wir folgenden Code-Schnipsel:</p>
<pre>
let x = 10;

function foo() {
  console.log(x);
}

function bar(funArg) {
  let x = 20;
  funArg(); // 10, not 20!
}

// Übergebe `foo` als Parameter an `bar`.
bar(foo);
</pre>
<p>Aus Sicht der Funktion <code>foo</code> ist die Variable <code>x</code> eine freie Variable. Wenn die Funktion <code>foo</code> aufgerufen wird (als Parameter <code>funArg</code>), so muss die Verbindung für <code>x</code> aufgelöst werden. Woher kommt nun diese Verbindung? Aus dem <em>äußeren Geltungsbereich</em>, in dem die Funktion <em>erzeugt</em> wurde? Oder aus dem <em>Geltungsbereich des Aufrufers</em>, der die Funktion schließlich aufruft? Wie wir im Beispiel sehen, stellt der Aufrufer, das ist die Funktion <code>bar</code>, ebenfalls eine Verbindung zwischen <code>x</code> und dem Wert <code>20</code> bereit.</p>
<p>Der obige Anwendungsfall ist als <strong><em>Abwärts-Funarg-Problem</em></strong> (<em lang='en'>downward funarg problem</em>) bekannt. Das Problem besteht in einer <em>Mehrdeutigkeit</em> beim Bestimmen der <em>korrekten Umgebung</em> einer Verbindung: Wird die Umgebung zum <em>Zeitpunkts der Erzeugung</em> verwendet oder die Umgebung zum <em>Zeitpunkts des Aufrufs</em>?</p>
<p>ECMAScript löst das Problem, indem man sich auf einen <em>statischen</em>, das heißt unveränderlichen Geltungsbereich geeinigt hat. Das ist der Geltungsbereich zum <em>Zeitpunkt der Erzeugung</em>.</p>
<p class='definition'><strong>Definition 13: Statischer Geltungsbereich:</strong> Eine Sprache arbeitet mit einem <em>statischen Geltungsbereich</em> (<em lang='en'>static scope</em>), wenn alleine durch das Anschauen des Quellcodes bestimmt werden kann, in welcher Umgebung eine Verbindung aufgelöst wird.</p>
<p>Der statische Geltungsbereich wird auch manchmal <em>lexikalischer Geltungsbereich</em> (<em lang='en'>lexical scope</em>) genannt. Daher stammt die Bezeichnung für die <em>lexikalischen Umgebungen</em>.</p>
<p>Intern wird der statische Geltungsbereich folgendermaßen umgesetzt: Zum Zeitpunkt der <em>Erzeugung</em> einer Funktion wird deren Umgebung <em>festgehalten</em> und gespeichert.</p>
<p class='note'><strong>Hinweis:</strong> Erfahren Sie mehr über <em>statische</em> und <em>dynamische</em> Geltungsbereiche <a href='https://codeburst.io/js-scope-static-dynamic-and-runtime-augmented-5abfee6223fe'>in diesem Artikel</a>.</p>
<p>Im obigen Beispiel hält die Funktion <code>foo</code> die <em>globale Umgebung</em> fest:</p>
<figure>
  <img src='closure.png' width='400' alt='Abbildung 8. Eine Closure.'>
  <figcaption>
    <p>Abbildung 8. Eine Closure.</p>
    <table>
      <caption>Legende</caption>
      <tr><th lang='en'>Global env</th><td>Globale Umgebung</td></tr>
      <tr><th lang='en'>Global EnvRec</th><td>Globales Umgebungsregister</td></tr>
    </table>
  </figcaption>
</figure>
<p>Wir sehen hier eine Umgebung, die auf eine Funktion verweist, welche wiederum <em>zurück</em> auf die Umgebung verweist.</p>
<p class='definition'><strong>Definition 14: Closure:</strong> Eine <em>Closure</em> (zu Deutsch auch <em>Funktionsabschluss</em>) ist eine Funktion, die diejenige <em>Umgebung einschließt</em>, in der sie <em>definiert</em> ist. Im Weiteren wird die Umgebung zur <em>Auflösung von Bezeichnern</em> genutzt.</p>
<p class='note'><strong>Hinweis:</strong> Wird eine Funktion aufgerufen, so wird eine <em>neue, leere Aktivierungsumgebung</em> erzeugt. Darin werden <em>lokale Variablen</em> und die <em>Funktionsparameter</em> gespeichert. Als <em>Eltern-Umgebung</em> dieser Aktivierungsumgebung wird nun die <em>eingeschlossene Umgebung</em> der Funktion auserkoren. So wird die Semantik des <em>lexikalischen Geltungsbereiches</em> erreicht.</p>
<p>Der zweite Untertyp des Funarg-Problems ist das <strong><em>Aufwärts-Funarg-Problem</em></strong>. Der einzige Unterschied hier ist, dass die einschließende Umgebung <em>länger lebt</em> als der Kontext, der sie erzeugt.</p>
<p>Ein Beispiel:</p>
<pre>
function foo() {
  let x = 10;

  // Closure, die die Umgebung von `foo` einschließt
  function bar() {
    return x;
  }

  // Funktionaler Parameter »aufwärts«
  return bar;
}

let x = 20;

// Der Aufruf von `foo` gibt die Closure `bar` zurück.
let bar = foo();

bar(); // 10, nicht 20!
</pre>
<p>Technisch gesehen haben wir es mit dem gleichen Mechanismus zu tun, der die Umgebung festhält, in dem eine Funktion definiert wurde. In diesem Fall jedoch würde die Aktivierungsumgebung von <code>foo</code> <em>zerstört werden</em>, wenn es die Closure nicht gäbe. Aber wir haben sie <em>festgehalten</em>, sodass sie nicht aus dem Speicher geräumt (dealloziert) wird. Daher bleibt die Aktivierungsumgebung erhalten, um das Verhalten des <em>statischen Geltungsbereichs</em> zu ermöglichen.</p>
<p>Das Verständnis von Closures ist oftmals unvollständig: Meist denken Entwickler nur an das Aufwärts-Funarg-Problem, wenn es um Closures geht. Tatsächlich tritt dieser Fall in der Praxis häufiger auf. Allerdings ist die technische Lösung des Abwärts-Problems <em>genau dieselbe</em> wie die des Aufwärts-Problems, nämlich der <em>statische Geltungsbereich</em>.</p>
<p>Wie gesagt können sich <em>mehrere</em> Closures ein und dieselbe Elternumgebung <em>teilen</em>, ähnlich wie es bei Prototypen der Fall ist. Dies ermöglicht es, auf die geteilten Daten zuzugreifen und diese auch zu ändern:</p>
<pre>
function createCounter() {
  let count = 0;

  return {
    increment() { count++; return count; },
    decrement() { count--; return count; },
  };
}

let counter = createCounter();

console.log(
  counter.increment(), // 1
  counter.decrement(), // 0
  counter.increment(), // 1
);
</pre>

<p>Beide Closures, <code>increment</code> und <code>decrement</code>, werden im Geltungsbereich erzeugt, der auch die Variable <code>count</code> enthält. Sie <em>teilen</em> sich daher den <em>Eltern-Geltungsbereich</em>. Das Festhalten erfolgt durch das Anlegen eines Verweises (<em lang='en'>by reference</em>). Es wird also ein <em>Verweis</em> auf die <em>Elternumgebung als solche</em> gespeichert.</p>
<p>Das folgende Bild illustriert dies:</p>
<figure>
  <img src='shared-environment.png' width='600' alt='Abbildung 9. Eine geteilte Umgebung.'>
  <figcaption>
    <p>Abbildung 9. Eine geteilte Umgebung.</p>
    <table>
      <caption>Legende</caption>
      <tr><th lang='en'>createCounter env</th><td>Umgebung von createCounter</td></tr>
      <tr><th lang='en'>createCounter EnvRec</th><td>Umgebungsregister von createCounter</td></tr>
    </table>
  </figcaption>
</figure>
<p>In manchen Sprachen erfolgt das Festhalten durch das <em>Kopieren der Variable</em> mitsamt ihres Wertes (<em lang='en'>by value</em>). Es ist dann nicht möglich, den Wert der Variable in der Elternumgebung zu ändern. In JavaScript hingegen wird wie gesagt immer ein <em>Verweis</em> auf den Eltern-Geltungsbereich angelegt.</p>
<p class='note'><strong>Hinweis:</strong> ECMAScript-Implementierungen können diesen Schritt optimieren, indem sie nicht die ganze Umgebung festhalten. Sie brauchen nur <em>tatsächlich benutzte</em> freie Variablen festhalten. Das Verhalten bei Datenänderungen im Eltern-Geltungsbereich bleibt dadurch unangetastet.</p>
<p>Sie finden eine genaue Beschreibung von Closures und des Funarg-Problems <a href='http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/'>im entsprechenden Kapitel</a>.</p>
<p>Alle Bezeichner werden also in einem statischen Geltungsbereich aufgelöst. Es gibt jedoch <em>genau einen</em> Wert in ECMAScript, der <em>dynamisch aufgelöst</em> wird. Es ist der Wert <code>this</code>.</p>

<h2 id='this'>This</h2>
<p>Der Wert <code>this</code> ist ein spezielles Objekt, das <em>dynamisch</em> und <em>implizit</em> an den Code eines Kontexts übergeben wird. Wir können ihn als <em>zusätzlichen impliziten Parameter</em> verstehen, auf den wir zwar zugreifen können, der sich aber nicht nachträglich ändern lässt.</p>
<p>Der Sinn und Zweck des Werts <code>this</code> ist, dass derselbe Code für mehrere Objekte ausgeführt werden kann.</p>
<p class='definition'><strong>Definition 15: This:</strong> Ein implizites <em>Kontextobjekt</em>, auf das der Code eines Ausführungskontexts Zugriff hat, um denselben Code für mehrere Objekte auszuführen.</p>
<p>Der wichtigste Anwendungsfall ist die klassen-basierte, objekt-orientierte Programmierung. Eine Instanzmethode, die am Prototyp definiert ist, existiert <em>nur einmal</em>, aber <em>alle Instanzen</em> der Klasse teilen sie sich.</p>
<pre>
class Point {
  constructor(x, y) {
    this._x = x;
    this._y = y;
  }

  getX() {
    return this._x;
  }

  getY() {
    return this._y;
  }
}

let p1 = new Point(1, 2);
let p2 = new Point(3, 4);

// `getX` und `getY` sind an beiden Instanzen verfügbar.
// Die Instanz wird jeweils als `this` übergeben.

console.log(
  p1.getX(), // 1
  p2.getX(), // 3
);
</pre>
<p>Wenn die Methode <code>getX</code> aufgerufen wird, wird eine neue Umgebung erzeugt, um die lokalen Variablen und Parameter zu speichern. Zudem bekommt der Eintrag <code>[[ThisValue]]</code> im <em>Funktions-Umgebungsregister</em> einen Wert zugewiesen. Dieser Wert wird <em>dynamisch</em> bestimmt abhängig davon, wie die Funktion aufgerufen wird. Word die Funktion als Methode von <code>p1</code> aufgerufen, so ist der <code>this</code>-Wert eben <code>p1</code>. Im zweiten Fall ist der Wert <code>p2</code>.</p>
<p>Ein weiterer Anwendungsfall von <code>this</code> sind <em>generische Interface-Funktionen</em>, wie sie in <em>Mixins</em> oder <em>Traits</em> Verwendung finden.</p>
<p>Im folgenden Beispiel enthält das <code>Movable</code>-Interface eine generische (verallgemeinerte) Funktion <code>move</code>. Sie erwartet von den Nutzern des Mixins, dass sie die Eigenschaften <code>_x</code> und <code>_y</code> implementieren:</p>
<pre>
// Generisches Movable-Interface (Mixin).
let Movable = {

  /**
   * Diese Funktion ist generisch und arbeitet mit jedem Objekt zusammen,
   * das die Eigenschaften `_x` und `_y` bereitstellt, ungeachtet
   * der Klasse des Objekts.
   */
  move(x, y) {
    this._x = x;
    this._y = y;
  },
};

let p1 = new Point(1, 2);

// Mache `p1` beweglich (Wende den Mixin an)
Object.assign(p1, Movable);

// Die Methode `move` kann nun aufgerufen werden.
p1.move(100, 200);

console.log(p1.getX()); // 100
</pre>
<p>Alternativ kann ein Mixin auf der <em>Ebene des Prototyps</em> angewandt werden, anstatt bei <em>jeder Instanz einzeln</em> wie im obigen Beispiel.</p>
<p>Das folgende Beispiel demonstriert die dynamische Natur des Wertes <code>this</code>. Es zu verstehen ist eine kleine Aufgabe für Sie:</p>
<pre>
function foo() {
  return this;
}

let bar = {
  foo,

  baz() {
    return this;
  },
};

// `foo`
console.log(
  foo(),       // Das globale Objekt oder undefined

  bar.foo(),   // bar
  (bar.foo)(), // bar

  (bar.foo = bar.foo)(), // Das globale Objekt
);

// `bar.baz`
console.log(bar.baz()); // bar

let savedBaz = bar.baz;
console.log(savedBaz()); // Das globale Objekt
</pre>
<p>Allein durch das Anschauen des Quellcodes der Funktion <code>foo</code> können wir <em>nicht vorhersagen</em>, welchen Wert <code>this</code> bei einem <em>bestimmten Funktionsaufruf</em> haben wird. Deshalb spricht man davon, dass <code>this</code> <em>dynamisch aufgelöst</em> wird.</p>
<p class='note'><strong>Hinweis:</strong> Sie finden eine genaue Erklärung, wie der Wert <code>this</code> bestimmt wird, <a href='http://dmitrysoshnikov.com/ecmascript/chapter-3-this/'>im entsprechenden Kapitel</a>. Es erklärt auch, wieso sich der Code im Beispiel so verhält, wie er sich verhält.</p>
<p>Die <strong><em>Pfeil-Funktionen</em></strong> (<em lang='en'>arrow functions</em>) verhalten sich ungewöhnlich hinsichtlich des Wertes <code>this</code>: Darin ist <code>this</code> <em>lexikalisch (statisch)</em> und <em>nicht dynamisch</em>. Das heißt, ihr Funktions-Umgebungsregister enthält <em>keinen Wert für <code>this</code></em>. Stattdessen wird der Wert der Elternumgebung verwendet.</p>
<pre>
var x = 10;

let foo = {
  x: 20,

  // Dynamisches `this`.
  bar() {
    return this.x;
  },

  // Lexikalisches `this`.
  baz: () =&gt; this.x,

  qux() {
    // Lexikalisches this im Zusammenhang mit diesem Aufruf.
    let arrow = () =&gt; this.x;

    return arrow();
  },
};

console.log(
  foo.bar(), // 20, aus `foo`
  foo.baz(), // 10, aus dem globalen Objekt
  foo.qux(), // 20, aus `foo` und der Pfeil-Funktion
);
</pre>
<p>Wie gesagt ist der Wert von <code>this</code> im <em>globalen Kontext</em> das <em>globale Objekt</em> (das <em>Verbindungsobjekt</em> des <em>globalen Umgebungsregisters</em>). Früher gab es nur ein globales Objekt. In der aktuellen Version der ECMAScript-Spezifikation kann es <em>mehrere globale Objekte</em> geben, die Teil von <em>Code-Gebieten</em> sind. Schauen wir uns nun diese Struktur an.</p>

<h2 id='realm'>Gebiet</h2>
<p>Bevor ECMAScript-Code ausgewertet wird, muss er einem <em>Gebiet</em> zugewiesen werden. Die Aufgabe eines Gebiets ist, eine globale Umgebung für einen Kontext bereitzustellen.</p>
<p class='definition'><strong>Definition 16: Gebiet:</strong> Ein <em>Code-Gebiet</em> (<em lang='en'>realm</em>) ist ein Objekt, das eine eigenständige <em>globale Umgebung</em> umhüllt.</p>
<p>Wenn ein <em>Ausführungskontext</em> erzeugt wird, wird er einem bestimmten <em>Code-Gebiet</em> zugeordnet. Das Gebiet stellt die <em>globale Umgebung</em> für diesen Kontext bereit. Diese Zuordnung ist <em>unveränderlich</em>.</p>
<p class='note'><strong>Hinweis:</strong> Das direkte Äquivalent eines Gebiets im Browser ist das <code>iframe</code>-Element, welches eine eigene globale Umgebung bereitstellt. Bei Node.js sind die Sandkasten (<em lang='en'>sandboxes</em>) aus dem <a href='https://nodejs.org/api/vm.html'>vm-Modul</a> mit Gebieten vergleichbar.</p>
<p>Die aktuelle Version der ECMAScript-Spezifikation bietet keine Möglichkeit, um Gebiete programmatisch zu erstellen. Sie können jedoch implizit von den Implementierungen erstellt werden. Es gibt einen <a href='https://github.com/tc39/proposal-realms/'>Vorschlag</a>, der vorsieht, diese Programmierschnittstelle (API) für gewöhnlichen Code zugänglich zu machen.</p>
<p>Jeder Kontext auf dem Stapel hat eine logische Verbindung zu seinem Gebiet:</p>
<figure>
  <img src='context-realm.png' width='400' alt='Abbildung 10. Ein Kontext und seine Verbindung zum Gebiet.'/>
  <figcaption>
    <p>Abbildung 10. Ein Kontext und seine Verbindung zum Gebiet.</p>
    <table>
      <caption>Legende</caption>
      <tr><th lang='en'>EC stack</th><td>Stapel der Ausführungskontexte</td></tr>
      <tr><th lang='en'>Realm 1, Realm 2</th><td>Gebiet 1, Gebiet 2</td></tr>
    </table>
  </figcaption>
</figure>
<p>Schauen wir uns ein Beispiel mit unterschiedlichen Gebieten an, erzeugt durch das <code>vm</code>-Modul:</p>
<pre>
const vm = require('vm');

// Erstes Gebiet und sein globales Objekt:
const realm1 = vm.createContext({x: 10, console});

// Zweites Gebiet und sein globales Objekt:
const realm2 = vm.createContext({x: 20, console});

// Code, der ausgeführt wird:
const code = `console.log(x);`;

vm.runInContext(code, realm1); // 10
vm.runInContext(code, realm2); // 20
</pre>
<p>Langsam bekommen wir eine Übersicht über die ECMAScript-Laufzeitumgebung. Wir müssen aber noch den <em>Einstiegspunkt</em> zum Code finden sowie den <em>Initialisierungsprozess</em>. Dieser wird geregelt durch den Mechanismus der <em>Aufträge</em> und der <em>Auftrags-Warteschlange</em>.</p>

<h2 id='job'>Auftrag</h2>
<p>Manche Operationen können aufgeschoben werden und erst ausgeführt werden, sobald ein Platz im Stapel der Ausführungskontexte frei wird.</p>
<p class='definition'><strong>Definition 17: Auftrag:</strong> Ein <em>Auftrag</em> (<em lang='en'>job</em>) ist eine abstrakte Operation, die eine ECMAScript-Berechnung startet, sobald <em>keine andere</em> Berechnung mehr läuft.</p>
<p>Aufträge werden in die <strong><em>Auftrags-Warteschlange</em></strong> eingereiht. In der aktuellen Spezifikation gibt es zwei solcher Warteschlangen: <strong><em>ScriptJobs</em></strong> und <strong><em>PromiseJobs</em></strong>.</p>
<p>Der <em>erste Auftrag</em> in der <em>ScriptJobs</em>-Warteschlange ist der <em>Haupt-Einstiegspunkt</em> zu unserem Programm. Der Auftrag lädt das erste Script und wertet es aus: ein Gebiet wird erzeugt, der globale Kontext wird erzeugt und mit dem Gebiet verknüpft, er wird auf den Stapel gelegt und der globale Code wird ausgeführt.</p>
<p>Beachten Sie, dass die <em>ScriptJobs</em>-Warteschlange sowohl für <em>Scripte</em> als auch für <em>Module</em> zuständig ist.</p>
<p>Dieser anfängliche Kontext kann später <em>weitere Kontexte</em> hervorbringen oder <em>weitere Aufträge</em> in die Warteschlange einreihen. Ein Beispiel für einen Auftrag, der erzeugt und eingereiht wird, ist ein <em>Promise</em>.</p>
<p>Wenn es <em>keinen aktiven</em> Ausführungskontext gibt und der Stapel von Ausführungskontexten <em>leer</em> ist, so nimmt die ECMAScript-Implementierung den <em>ersten wartenden Auftrag</em> aus der Warteschlange und arbeitet ihn ab. Dazu wird ein Ausführungskontext erzeugt und seine Ausführung gestartet.</p>
<p class='note'><strong>Hinweis:</strong> Auftrags-Warteschlangen werden üblicherweise mithilfe des Konzepts der <strong><em>»Ereignisschleife«</em></strong> (<em lang='en'>event loop</em>) abgearbeitet. Der ECMAScript-Standard definiert die Ereignisschleife nicht und überlässt sie den Implementierungen. Sie können jedoch <a href='https://gist.github.com/DmitrySoshnikov/26e54990e7df8c3ae7e6e149c87883e4'>ein Lehrbeispiel hier finden</a>.</p>
<p>Ein Beispiel:</p>
<pre>
// Füge einen neuen Promise zur PromiseJobs-Warteschlange hinzu.
new Promise(resolve =&gt; setTimeout(() =&gt; resolve(10), 0))
  .then(value =&gt; console.log(value));

// Diese Ausgabe findet vorher statt, da sie Teil des aktiven Kontexts
// ist. Der anstehende Auftrag vorher nicht abgearbeitet werden.
console.log(20);

// Ausgabe: 20, 10
</pre>
<p class='note'><strong>Hinweis:</strong> Mehr über Promises finden Sie <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise'>in dieser Dokumentation</a>.</p>
<p><strong><em>Asynchrone Funktionen</em></strong>, die mit dem Schlüsselwort <code>async</code> definiert werden, können mit <code>await</code> auf Promises warten. Sie können darüber ebenfalls Promise-Aufträge einreihen:</p>
<pre>
async function later() {
  return await Promise.resolve(10);
}

(async () =&gt; {
  let data = await later();
  console.log(data); // 10
})();

// Dies passiert ebenfalls vorher, da die asynchrone Ausführung
// zunächst in der PromiseJobs-Warteschlange wartet.
console.log(20);

// Output: 20, 10
</pre>
<p class='note'><strong>Hinweis:</strong> Lesen Sie mehr über <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function'>asynchrone Funktionen hier</a>.</p>
<p>Wir sind dem Ziel näher gekommen, einen vollständigen Überblick über das derzeitige ECMAScript-Universum zu bekommen. Wenden wir uns schließlich den <em>Haupteignern</em> aller genannten Komponenten zu, den <em>Agenten</em>.</p>

<h2 id='agent'>Agent</h2>
<p><em>Nebenläufigkeit</em> (<em lang='en'>concurrency</em>) und <em>parallele Programmierung</em> sind in ECMAScript mithilfe des <em>Agenten-Musters</em> (<em lang='en'>agent pattern</em>) umgesetzt. Das Agenten-Muster ähnelt dem <a href='https://de.wikipedia.org/wiki/Actor_Model'>Aktorenmodell</a>. Aktoren sind <em>leichtgewichtige Prozesse</em>, die miteinander kommunizieren, indem sie <em>Nachrichten austauschen</em>.</p>
<p class='definition'><strong>Definition 18: Agent:</strong> Ein <em>Agent</em> ist eine Abstraktion, die den Stapel von Ausführungskontexten, eine Anzahl von Auftrags-Warteschlangen sowie Code-Gebiete beinhaltet.</p>
<p>Abhängig von der Implementierung kann ein Agent auf demselben oder einem eigenen Thread ausgeführt werden. In der Browserumgebung ist der <em>Worker</em> ein Beispiel für das Agenten-Konzept.</p>
<p>Die Agenten haben einen voneinander getrennten, also <em>isolierten Zustand</em> und können miteinander kommunizieren, indem sie <em>Nachrichten austauschen</em>. Bestimmte Daten können zwischen Agenten geteilt werden, zum Beispiel <code>SharedArrayBuffer</code>. Agenten können zudem zusammengefasst werden in <em>Agentengruppen</em>.</p>
<p>Im folgenden Beispiel ruft der Code in <code>index.html</code> den Worker in <code>agent-smith.js</code> auf und übergibt ihm einen geteilten Speicherbereich:</p>
<pre>
// Der Code in `index.html`:

// Geteilte Daten zwischen diesem Agent und einem Worker.
let sharedHeap = new SharedArrayBuffer(16);

// Unsere Sicht auf die Daten.
let heapArray = new Int32Array(sharedHeap);

// Erzeuge einen neuen Agenten (Worker).
let agentSmith = new Worker('agent-smith.js');

agentSmith.onmessage = (message) =&gt; {
  // Der Agent sendet den Index der Daten, die er modifiziert hat.
  let modifiedIndex = message.data;

  // Überprüfe, ob die Daten geändert wurden:
  console.log(heapArray[modifiedIndex]); // 100
};

// Sende die geteilten Daten an den Agenten.
agentSmith.postMessage(sharedHeap);
</pre>
<p>Hier der Worker-Code:</p>
<pre>
// agent-smith.js

// Empfange den geteilten Array-Buffer in diesem Worker.
onmessage = (message) =&gt; {
  // Die Sicht des Workers auf die geteilten Daten.
  let heapArray = new Int32Array(message.data);

  let indexToModify = 1;
  heapArray[indexToModify] = 100;

  // Sende den Index in einer Nachricht zurück.
  postMessage(indexToModify);
};
</pre>
<p>Sie finden den kompletten Code für das obige Beispiel <a href='https://gist.github.com/DmitrySoshnikov/b75a2dbcdb60b18fd9f05b595135dc82'>in diesem Gist</a>.</p>
<p>(Beachten Sie: Wenn Sie das Beispiel lokal aufrufen, sollten Sie es im Firefox laufen lassen. Aus Sicherheitsgründen erlaubt Chrome das Laden von Web-Workern aus einer lokalen Datei nicht.)
<p>Die folgende Illustration zeigt die gesamte ECMAScript-Laufzeitumgebung:</p>
<figure>
  <img src='agents-1.png' width='500' alt='Abbildung 11. Die ECMAScript-Laufzeitumgebung.'>
  <figcaption>Abbildung 11. Die ECMAScript-Laufzeitumgebung.</figcaption>
</figure>
<p>Und das ist schon alles! Das ist, was unter der Motorhaube von ECMAScript passiert!</p>
<p>Wir kommen nun zum Ende. Dies sind alle Informationen zum JavaScript-Kern, die ein Überblicksartikel abdecken kann. Wie gesagt kann JavaScript-Code in <em>Modulen</em> gruppiert werden, der Zugriff auf Eigenschaften kann durch <code>Proxy</code>-Objekte abgefangen werden usw. usf. Es gibt viele praxisrelevante Details, über die Sie in anderen Dokumentationen der Sprache JavaScript lesen können.</p>
<p>Dieser Artikel hingegen hat versucht, die <em>logische Struktur</em> eines ECMAScript-Programms darzustellen. Falls Sie Fragen, Anregungen oder Feedback haben: wie immer freue ich mich darauf, sie <a href='http://dmitrysoshnikov.com/ecmascript/javascript-the-core-2nd-edition/#comments'>im Kommentarbereich</a> zu diskutieren.</p>
<p>Ich möchte mich bei den Mitgliedern der <abbr title='Technical Committee' lang='en'>TC</abbr>-39-Arbeitsgruppe und den AutorInnen der Spezifikation bedanken, die mir mit Erklärungen bei diesem Artikel geholfen haben. Die Diskussion finden Sie <a href='https://twitter.com/DmitrySoshnikov/status/930507793047592960'>in diesem Twitter-Thread</a>.</p>
<p>Viel Erfolg beim Lernen von ECMAScript!</p>
<p>
<strong>Autor:</strong> Dmitry Soshnikov<br>
<strong>Veröffentlicht am:</strong> <time datetime='2017-11-14'>14. November 2017</time>
</p>

<hr>

<p>
<strong>Deutsche Übersetzung:</strong> <a href='https://molily.de/'>Mathias Schäfer (molily)</a>. Dank geht an Ingo Chao, Peter Seliger, Axel Wienberg, Jo Liss und Julian Tauert für ihre Mitarbeit.<br>
<strong>Veröffentlicht am</strong> <time datetime="2018-01-31">31. Januar 2018</time>
</p>

<p><a href='https://github.com/molily/jscore-de'>Das Übersetzungsprojekt auf GitHub</a>.</p>
<p>Feedback und Korrekturen bitte an <a href='mailto:zapperlott@gmail.com'>zapperlott@gmail.com</a> oder als <a href='https://github.com/molily/jscore-de'>Issues auf GitHub</a>.</p>

</body>
</html>
